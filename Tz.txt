Проект "Сервис суточного бронирования квартир и комнат".
Цель проекта: предоставить функционал для агенства недвижимости бронировать квартиры посуточно.
Агенство недвижимости будет находить собственников квартир(комнат) и предлагать сдавать квартиры посуточно.
Если собственник соглашается, то его помещение заносится в базу данных. Далее агент формирует объявление, где пишет сколько стоит аренда данной квартиры на сутки, прикрепляя описание.
Объявление размещается на сайте агенства недвижимости и его видят пользователи интернета. Понравившуюся квартиру(комнату) пользователь может забронировать на определенные даты.

-- Этап №1 - Создание приложения и структуры бд
-- 1. Создать базу данных flat_rent.
-- 2. Создать Spring-boot проект (spring-data-jpa, web, lombok, checkstyle, liquibase, postgresql driver)
-- 3. Настроить подключение к базе из java
-- 4. С помощью скриптов liquibase спроектировать бд.
У всех колонок НЕ может быть значение null(!).
-- Не забывайте про создание id у таблиц.
-- 4.1. Помещение (apartment) - город, улица, дом (может быть корпус), количество комнат ( только комната, 1-комнатная, 2-комнатная, 3-комнатная, 4 и более комнатная квартира)
-- 4.2. Объявление (advert) - цена за ночь, статус (активно или архивное), ссылка на помещение, описание
-- 4.3. Клиент (client) - Имя клиента, email клиента (УНИКАЛЬНЫЙ)
-- 4.4. Бронирование (booking) - дата начала бронирования, дата окончания бронирования, ссылка на клиента, ссылка на объявление, стоимость всего бронирования.


Этап №2 - Описание сущностей бд в java и создание типовых репозиториев для работы с ними.
-- 1. Создать классы сущности, описывающие соответствующие сущности из бд: Должны появиться классы enity Apartment, Client, Advert, Booking.
Данные классы должны отображать всю структуру таблиц.
-- 2. У entity Apartment "количество комнат" должно быть enum.
-- 2. Создать jpa репозитории под каждую entity.
-- Проверьте что вы можете сохранить экземпляр каждой сущности (после проверки удалите лишний код).


Этап №3 - Создание связи между сущностями
-- 1. Необходимо заменить в классах entity использование полей с id на экземпляры сущностей.
При этом связи должны быть двух сторонние.
Например: из объявления мы можем получить помещение, на которое это объявление ссылается. Из помещения мы можем увидеть все объявления, которые ссылаются на данное помещение.

Как было до (иллюстрация):
Car {
	Integer id;
}

Human {
	Integer car_id;
}

Как должно стать:
Car {
  Integer id
  Human owner;
}

Human {
	Car car;
}
-- 2. При печати (toString) entity не должны появлятся связанные сущности
3. Entity сравниваются друг с другом только по id

Этап №4 - Создание сервисного слоя и мапперов (Без слоя контроллеров!).
Для маппинга из dto в entity и наоборот должен использоваться только(!) mapstruct.
Так как данные на вход содержат id связанных сущностей, тебе нужно будет преобразовать данные из dto в entity
и подтянуть связанные сущности по id.
Поэтому в маппере необходимо сделать метод (toEntityWithRelation), который примет dto (и больше ничего),
а в ответ отдаст сущность со связями.
(смотри https://github.com/Ablazzing/university-jpa/blob/master/src/main/java/com/javaacademy/student/mapper/StudentMapper.java)
Т.е. внутри маппера у будут отдельные методы на получение связанных сущностей,
над которыми будет висеть аннотация @Named
Например
@Named("getApartment)
protected Apartment getApartment(Integer apartmentId) {
	return apartmentRepository.findById(apartmentId);
}

После того как ты напишешь эти методы, ты сможешь с помощью аннотаций @Mapping собрать полную сущность.
Эта ситуация для двух сущностей необходима: advert, booking.

Необходимо:
-- 0. Подключить mapstruct.
-- 1. Создать сервис по работе с помещениями. Сервис должен уметь:
-- 1.1 Сохранять новое помещение. Формат входящих данных:
{
  "id": null,
  "city": "string",
  "street": "string",
  "house": "string",
  "apartment_type": "ONLY_ROOM"
}
-- 1.1.1 При создании помещения отдавать данные в том же формате, но с заполненным id.

2. Создать сервис по работе с клиентами. Сервис должен уметь:
-- 2.1 Создавать клиента. Формат входящих данных:
{
  "id": null,
  "name": "string",
  "email": "string"
}
-- 2.1.1 При создании клиента отдавать данные в том же формате, но с заполненным id.

-- 3. Создавать сервис по работе с объявлениями. Сервис должен уметь:
-- 3.1. Создавать новое объявление. Формат входящих данных:
{
  "id": null,
  "price": 0,
  "is_active": true,
  "apartment_id": 0
  "description": "string"
}
-- 3.1.1 Необходимо преобразовать эти данные в advert entity,
внутри которой будет лежать apartment entity (получить по id apartment entity, а не создать новую!).
-- 3.1.2 Сохранить advert в бд. Если такого apartment нет, advert не должен быть сохранен.
-- 3.1.3 Отдавать dto после сохранения сущности, в таком формате:
{
  "id": 0,
  "price": 0,
  "is_active": true,
  "apartment": {
    "id": 0,
    "city": "string",
    "street": "string",
    "house": "string",
    "apartment_type": "ONLY_ROOM"
  },
  "description": "string"
}

-- 4. Создать сервис по работе с бронированиями. Сервис должен уметь:
-- 4.1 Создавать бронирование. Формат входящих данных:
{
  "id": null,
  "client_id": 0,
  "advert_id": 0,
  "date_start": "2025-02-13",
  "date_finish": "2025-02-13"
}
-- 4.1.1 Формат данных выходящих:

{
  "id": 0,
  "client": {
    "id": 0,
    "name": "string",
    "email": "string"
  },
  "advert": {
    "id": 0,
    "price": 0,
    "is_active": true,
    "apartment": {
      "id": 0,
      "city": "string",
      "street": "string",
      "house": "string",
      "apartment_type": "ONLY_ROOM"
    },
    "description": "string"
  },
  "date_start": "2025-02-13",
  "date_finish": "2025-02-13",
  "result_price": 0
}

Этап №5 Создание бизнес логики и слоя контроллеров
1. Необходимо создать endpoint POST /apartment - будет создавать квартиры под сдачу
2. Необходимо создать endpoint POST /advert - будет создавать объявления по сдаче квартиры.
3. Необходимо создать endpoint GET /advert?city=Moscow - будет отдавать объявления по 10 штук для определенного города.
Сортировка по цене (от самой большой к самой маленькой)
4. Необходимо создать endpoint POST /booking - будет бронировать квартиру на определенную дату
(переписать существующую реализацию сохранения booking).
4.1. На вход придут данные :
{
  "id": null,
  "client": {
    "id": 0,
    "name": "string",
    "email": "string"
  },
  "advert_id": 0,
  "date_start": "2025-02-13",
  "date_finish": "2025-02-13"
}
4.1.1. Если заполнен id (не null) у клиента, то проверить его наличие. Если клиента с таким id нет, то выкинуть исключение
4.1.2. Если клиент не заполнен (null), то создать нового клиента.
4.2. В случае если квартира на эту дату занята, то должно быть выкинуто исключение. ВНИМАНИЕ, рассмотрим примеры пересекающихся бронирований:
4.2.1 Была успешно создана бронь на квартиру №1 с 1.10 по 10.10
4.2.2 При попытке создать бронь на квартиру №1 с 5 по 6 - будет ошибка
4.2.3 При попытке создать бронь на квартиру №1 с 29.09 по 02.10 - будет ошибка
4.2.4 При попытке создать бронь на квартиру №1 с 09.10 по 11.10 - будет ошибка
4.3. В случае возникновения ошибки при бронировании, созданный клиент не должен сохраниться.
5. Необходимо создать endpoint GET /booking?email=y228@ya.ru - который будет возвращать все бронирования для клиента с указанным email порциями по 20 штук.
6. Необходимо создать endpoint DELETE /client/{id} - который будет удалять клиента и все его бронирования
7. Покрыть тестами слой контроллеров (на все endpoint)
7.1. Для создания бронирований отработать 5 случаев:
Успешное бронирование, при незаполненности id у клиента. Проверить что создан новый клиент.
Успешное бронирование, при указанном id у клиента.
Неуспешное бронирование при существующем бронировании на эти даты (случай 4.2.2).
Неуспешное бронирование при существующем бронировании на эти даты (случай 4.2.3).
Неуспешное бронирование при существующем бронировании на эти даты (случай 4.2.4).
7.2. При удалении клиента, проверить что удаляются его брони.
8. Описать через Swagger контроллеры, dto